#!/bin/dash
# vim:ft=sh

# Kill all descendents on exit
trap 'exit' INT TERM
trap 'kill 0' EXIT

# Location for flocks
if [ -z "${SYSINFO_FLOCK_DIR}" ] ; then
  if [ -n "${XDG_CACHE_HOME}" ] ; then
    SYSINFO_FLOCK_DIR="${XDG_CACHE_HOME}/sysinfo"
  else
    SYSINFO_FLOCK_DIR="${XDG_CACHE_HOME}/sysinfo"
  fi
fi


#------------------------------------#
#  _____           _        __       #
# /  ___|         (_)      / _|      #
# \ `--. _   _ ___ _ _ __ | |_ ___   #
#  `--. \ | | / __| | '_ \|  _/ _ \  #
# /\__/ / |_| \__ \ | | | | || (_) | #
# \____/ \__, |___/_|_| |_|_| \___/  #
#         __/ |                      #
#        |___/                       #
#------------------------------------#
# Script(s) to print system information in a variety of formats.
#   Expects the following environment variables

#   - markup:   Decides how the text are going to be formatted
if [ -z "${markup}" ] ;   then markup='lemonbar'  ; fi
#   - name:     The module to launch
if [ -z "${name}" ] ;     then name='mpd'  ; fi
#   - instance: Additional argument to the module
if [ -z "${instance}" ] ; then instance='default' ; fi
#   - accent:   The color to apply to special characters
if [ -z "${accent}" ] ;   then accent='cyan'      ; fi

#----------#
#-DEFAULTS-#
#----------#
# If these variables are made available in the environment;
#   they take over default values
if [ -z "${SYSINFO_FLOCK_DIR}" ] ; then
  if [ -n "${XDG_CACHE_HOME}" ] ; then
    SYSINFO_FLOCK_DIR="${XDG_CACHE_HOME}/sysinfo"
  else
    SYSINFO_FLOCK_DIR="${HOME}/.cache/sysinfo"
  fi
fi
if [ -z "${SYSINFO_CAL_LOC}" ] ; then
  SYSINFO_CAL_LOC="${HOME}/Documents/Calendar"
fi
if [ -z "${SYSINFO_CAL_MAXLEN}" ] ; then
  SYSINFO_CAL_MAXLEN=30
fi
if [ -z "${SYSINFO_CPU_POLL}" ] ; then
  SYSINFO_CPU_POLL=30
fi
if [ -z "${SYSINFO_DATE_STYLE}" ] ; then
  SYSINFO_DATE_STYLE='regular'
fi
if [ -z "${SYSINFO_DISK_POLL}" ] ; then
  SYSINFO_DISK_POLL=900
fi
if [ -z "${SYSINFO_EMAIL_LOC}" ] ; then
  SYSINFO_EMAIL_LOC="${HOME}/Documents/Mail/Gmail"
fi
if [ -z "${SYSINFO_FAN_POLL}" ] ; then
  SYSINFO_FAN_POLL=5
fi
if [ -z "${SYSINFO_MEM_POLL}" ] ; then
  SYSINFO_MEM_POLL=30
fi
if [ -z "${SYSINFO_MPD_POLL}" ] ; then
  SYSINFO_MPD_POLL=30
fi
if [ -z "${SYSINFO_MPD_MAXLEN}" ] ; then
  SYSINFO_MPD_MAXLEN=20
fi
if [ -z "${SYSINFO_RSS_POLL}" ] ; then
  SYSINFO_RSS_POLL=600
fi
if [ -z "${SYSINFO_TODO_LOC}" ] ; then
  SYSINFO_TODO_LOC="${HOME}/Documents/Todo"
fi
if [ -z "${SYSINFO_TODO_MAXLEN}" ] ; then
  SYSINFO_TODO_MAXLEN=30
fi
if [ -z "${SYSINFO_UPDATE_POLL}" ] ; then
  SYSINFO_UPDATE_POLL=900
fi
# By default, DISPLAY is used to identify flags; translate this
if [ -n "${WAYLAND_DISPLAY}" ] ; then
  IDENTIFIER="${WAYLAND_DISPLAY}"
elif [ -n "${DISPLAY}" ] ; then
  IDENTIFIER="${DISPLAY}"
else
  IDENTIFIER="$$"
fi

#--------#
#-COLORS-#
#--------#
# If there are no base16 set defined; do base16-default-dark
if [ -z "${base00}" ] ; then base00='#181818' ; fi
if [ -z "${base01}" ] ; then base01='#282828' ; fi
if [ -z "${base02}" ] ; then base02='#383838' ; fi
if [ -z "${base03}" ] ; then base03='#585858' ; fi
if [ -z "${base04}" ] ; then base04='#b8b8b8' ; fi
if [ -z "${base05}" ] ; then base05='#d8d8d8' ; fi
if [ -z "${base06}" ] ; then base06='#e8e8e8' ; fi
if [ -z "${base07}" ] ; then base07='#f8f8f8' ; fi
if [ -z "${base08}" ] ; then base08='#ab4642' ; fi
if [ -z "${base09}" ] ; then base09='#dc9656' ; fi
if [ -z "${base0A}" ] ; then base0A='#f7ca88' ; fi
if [ -z "${base0B}" ] ; then base0B='#a1b56c' ; fi
if [ -z "${base0C}" ] ; then base0C='#86c1b9' ; fi
if [ -z "${base0D}" ] ; then base0D='#7cafc2' ; fi
if [ -z "${base0E}" ] ; then base0E='#ba8baf' ; fi
if [ -z "${base0F}" ] ; then base0F='#a16946' ; fi
# Dimming color is base03
dim="${base03}"
# Read accent color; and write it into the variable col
if   [ "${accent}" = 'frg' ]    ; then
  col="${base04}"
elif [ "${accent}" = 'bkg' ]    ; then
  col="${base01}"
elif [ "${accent}" = 'dim' ]    ; then
  col="${base03}"
elif [ "${accent}" = 'red' ]    ; then
  col="${base08}"
elif [ "${accent}" = 'orange' ] ; then
  col="${base09}"
elif [ "${accent}" = 'yellow' ] ; then
  col="${base0A}"
elif [ "${accent}" = 'green' ]  ; then
  col="${base0B}"nohup: ignoring input and appending output to 'nohup.out'
elif [ "${accent}" = 'cyan' ]   ; then
  col="${base0C}"
elif [ "${accent}" = 'indigo' ] ; then
  col="${base0D}"
elif [ "${accent}" = 'violet' ] ; then
  col="${base0E}"
elif [ "${accent}" = 'brown' ]  ; then
  col="${base0F}"
else # Invalid accent specification
  exit 1
fi

#####################################
#  _           _   _ _     _   _    #
# | |_ ___ ___| |_| |_|___| |_| |_  #
# | . | .'|  _| '_| | | . |   |  _| #
# |___|__,|___|_,_|_|_|_  |_|_|_|   #
#                     |___|         #
#####################################
# Backlight module;
#  * No instance needed
backlight_click_left ()   { true ; }
backlight_click_middle () { true ; }
backlight_click_right ()  { true ; }
backlight_scroll_up ()    { /usr/bin/light -A 1 ; }
backlight_scroll_down ()  { /usr/bin/light -U 1 ; }
backlight_print () {
  # Get the current brigtness value; in whole percent
  val="$(/usr/bin/light -Gs 'sysfs/backlight/auto' | awk '{printf "%.0f", $1}')"
  if [ -z "${val}" ] ; then
    exit 1
  fi
  # Determine the screen icon icon
  if   [ "${val}" -ge 75 ] ; then pre=" "
  elif [ "${val}" -ge 50 ] ; then pre=" "
  elif [ "${val}" -ge 25 ] ; then pre=" "
  else                            pre=" "
  fi
  # Print string
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    echo "%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${val}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    echo "{\"full_text\":\"<span color='${col}'>${pre}</span>${val}\"}"
  fi
}
backlight_wait () {
  backlight_print
  /usr/bin/acpi_listen | while read -r _line ; do
    if echo "${_line}" | grep --quiet --ignore-case 'brightness' ; then
      backlight_print
    fi
  done
}


#################################
#  _       _   _                #
# | |_ ___| |_| |_ ___ ___ _ _  #
# | . | .'|  _|  _| -_|  _| | | #
# |___|__,|_| |_| |___|_| |_  | #
#                         |___| #
#################################
# Battery module;
#  * Defaults to battery id 0
#  * Does not have any functions
battery_click_left () { true ; }
battery_click_middle () { true ; }
battery_click_right () { true ; }
battery_scroll_up () { true ; }
battery_scroll_down () { true ; }
battery_print () {
  # Default to 0
  if [ "${instance}" = 'default' ] ; then
    bid=0
  else
    bid="${instance}"
  fi
  # Get info on battery state
  bat="$(acpi --battery    | grep "Battery ${bid}" | head -n 1)"
  ada="$(acpi --ac-adapter | grep "Adapter ${bid}" | head -n 1)"
  # Return with error code early if there is no battery
  if [ -z "${bat}" ] ; then
      exit 1
  fi
  # Write important info to variables
  stat="$(echo "${bat}" | sed 's|Battery [0-9]: \([ ,A-Z,a-z]*\),.*|\1|')"
  perc="$(echo "${bat}" | sed 's|.*, \([0-9]\+\)%.*|\1|')"
  # Change the front icon to capacity; with sign if it's charging
  if [ "${stat}" = 'Charging' ] ; then
    if   [ "${perc}" -gt 99 ] ; then col='green'  ; pre=""
    elif [ "${perc}" -ge 90 ] ; then col='green'  ; pre=""
    elif [ "${perc}" -ge 80 ] ; then col='green'  ; pre=""
    elif [ "${perc}" -ge 60 ] ; then col='yellow' ; pre=""
    elif [ "${perc}" -ge 40 ] ; then col='yellow' ; pre=""
    elif [ "${perc}" -ge 30 ] ; then col='orange' ; pre=""
    elif [ "${perc}" -ge 20 ] ; then col='red'    ; pre=""
    else                             col='red'    ; pre=""
    fi
  else
    if   [ "${perc}" -ge 95 ] ; then col='green'  ; pre=""
    elif [ "${perc}" -ge 90 ] ; then col='green'  ; pre=""
    elif [ "${perc}" -ge 80 ] ; then col='green'  ; pre=""
    elif [ "${perc}" -ge 70 ] ; then col='yellow' ; pre=""
    elif [ "${perc}" -ge 60 ] ; then col='yellow' ; pre=""
    elif [ "${perc}" -ge 50 ] ; then col='orange' ; pre=""
    elif [ "${perc}" -ge 40 ] ; then col='orange' ; pre=""
    elif [ "${perc}" -ge 30 ] ; then col='red'    ; pre=""
    elif [ "${perc}" -ge 20 ] ; then col='red'    ; pre=""
    else                             col='red'    ; pre=""
    fi
  fi
  txt="${perc}"
  # Check if time info is available, and add it to text if it is
  if echo "${bat}" | grep -q -e 'until charged' -e 'remaining' ; then
    txt="${perc}, $(echo "${bat}" | awk '{print $5}' \
      | sed 's|\([0-9]\+:[0-9]\+\):[0-9]\+|\1|')"
  fi
  # Make the suffix into connected/not connected icon
  if [ "$(echo "${ada}" | awk '{print $3}')" = 'on-line' ] ; then
    suf=""
  else
    suf="ﮤ"
  fi
  # Formatting and printing
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    echo "%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${txt}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    png="<span color='${col}'>${pre}</span>${txt}<span color='${col}'>${suf}</span>"
    # Start assemling the json string
    echo "{\"full_text\":\"${png}\"}"
  fi
}
battery_wait () { # Listener loop
  # Also poll every 30 seconds
  poll_loop () {
    while : ; do
      sleep 30
      get_text || break
    done
  }
  poll_loop &
  # Subscribe to acpi_listen
  /usr/bin/acpi_listen | while read -r line ; do
    if echo "${line}" | grep --quiet --ignore-case 'battery\|ac_adapter' ; then
      get_text
    fi 
  done
}

###################################
#          _           _          #
#  ___ ___| |___ ___ _| |___ ___  #
# |  _| .'| | -_|   | . | .'|  _| #
# |___|__,|_|___|_|_|___|__,|_|   #
###################################
# Calendar module (depends on khal)
#  * Can specify location using SYSINFO_CAL_LOC
calendar_click_left   () { true ; }
calendar_click_middle () { true ; }
calendar_click_right  () {
  ( flock --nonblock 7 || exit 7
    if [ -x "${TERMINAL}" ] && [ -x '/usr/bin/khal' ] ; then
      "${TERMINAL}" /usr/bin/khal interactive
    fi
  ) 7>"${SYSINFO_FLOCK_DIR}/cal_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
calendar_scroll_up    () { true ; }
calendar_scroll_down  () { true ; }
calendar_print () {
  pre=' '
  txt="$(khal list | head -n 1)"
  # Mute if quiet
  if [ "${txt}" = 'No events' ] ; then
    mute='yes'
  else
    mute='no'
  fi
  # Shorten text
  if [ "$(echo "${txt}" | wc --chars)" -gt "${SYSINFO_CAL_MAXLEN}" ] ; then
    txt="$(echo "${txt}" | awk "{print substr(\$0, 1, ${SYSINFO_CAL_MAXLEN})}")…"
  fi
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    out="%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${txt}%{-u u- -o o-}"
    if [ "${mute}" = yes ] ; then
      echo "%{F${dim}}${out}%{F-}"
    else
      echo "${out}"
    fi
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    out="<span color='${col}'>${pre}</span>${txt}"
    if [ "${mute}" = yes ] ; then
      echo "{\"full_text\":\"${out}\",\"color\":\"${dim}\"}"
    else
      echo "{\"full_text\":\"${out}\"}"
    fi
  fi
}
calendar_wait () {
  calendar_print
  # Place inotify watch on the calendar directory, or exit gracefully
  while : ; do
    inotifywait --recursive --timeout -1 \
      --event modify --event move --event create --event delete \
      "${SYSINFO_CAL_LOC}" >/dev/null 2>&1 || exit 2
    calendar_print
    # Wait a while before trying to add watches again
    sleep 5
  done
}

#######################
#      _         _    #
#  ___| |___ ___| |_  #
# |  _| | . |  _| '_| #
# |___|_|___|___|_,_| #
#######################
# Clock module;
#  * Takes no arguments
clock_click_left   () { true ; }
clock_click_middle () { true ; }
clock_scroll_up    () { true ; }
clock_scroll_down  () { true ; }
clock_click_right  () { true ; }
clock_print () {
  # Change icon depending on the hour
  hour="$(date '+%H')"
  if   [ "${hour}" = '00' ] || [ "${hour}" = '12' ] ; then pre=" "
  elif [ "${hour}" = '01' ] || [ "${hour}" = '13' ] ; then pre=" "
  elif [ "${hour}" = '02' ] || [ "${hour}" = '14' ] ; then pre=" "
  elif [ "${hour}" = '03' ] || [ "${hour}" = '15' ] ; then pre=" "
  elif [ "${hour}" = '04' ] || [ "${hour}" = '16' ] ; then pre=" "
  elif [ "${hour}" = '05' ] || [ "${hour}" = '17' ] ; then pre=" "
  elif [ "${hour}" = '06' ] || [ "${hour}" = '18' ] ; then pre=" "
  elif [ "${hour}" = '07' ] || [ "${hour}" = '19' ] ; then pre=" "
  elif [ "${hour}" = '08' ] || [ "${hour}" = '20' ] ; then pre=" "
  elif [ "${hour}" = '09' ] || [ "${hour}" = '21' ] ; then pre=" "
  elif [ "${hour}" = '10' ] || [ "${hour}" = '22' ] ; then pre=" "
  elif [ "${hour}" = '11' ] || [ "${hour}" = '23' ] ; then pre=" "
  else pre=" "
  fi
  txt="$(date '+%H:%M')"
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    echo "%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${txt}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    echo "{\"full_text\":\"<span color='${col}'>${pre}</span>${txt}\"}"
  fi
}
clock_wait () {
  # Poll the time every minute, starting from the start of every minute
  clock_print
  # The first wait should be until the end of the current minute
  sleep "$(( 1 + 60 - $(date '+%S') ))"
  while : ; do
    clock_print
    sleep 60
  done
}

#################
#  ___ ___ _ _  #
# |  _| . | | | #
# |___|  _|___| #
#     |_|       #
#################
# CPU module;
#  * Taken no arguments
#  * Can change interval using env SYSINFO_CPU_POLL
cpu_click_left   () { true ; }
cpu_click_middle () { true ; }
cpu_click_right  () {
  ( flock --nonblock 7 || exit 7
    if [ -x "${TERMINAL}" ] && [ -x '/usr/bin/htop' ] ; then
      "${TERMINAL}" /usr/bin/htop
    fi
  ) 7>"${SYSINFO_FLOCK_DIR}/cpu_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
cpu_scroll_up    () { true ; }
cpu_scroll_down  () { true ; }
cpu_print () {
  # Get data from /proc/loadavg
  data="$(cat /proc/loadavg || exit 1)"
  # Get average load for last minute
  avg="$(echo "${data}" | awk '{printf("%.1f",$1)}')"
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    echo "%{u${col} +u o${col} +o}%{F${col}} %{F-}${avg}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    echo "{\"full_text\":\"<span color='${col}'> </span>${avg}\"}"
  fi
}
cpu_wait () {
  cpu_print
  while : ; do
    sleep "${SYSINFO_CPU_POLL}"
    cpu_print || exit 2
  done
}

#####################
#    _     _        #
#  _| |___| |_ ___  #
# | . | .'|  _| -_| #
# |___|__,|_| |___| #
#####################
# Date module
#  * No argument is used
#  * Can change style using the environment variable SYSINFO_DATE_STYLE
date_click_left   () { true; }
date_click_middle () { true ; }
date_scroll_up    () { true ; }
date_scroll_down  () { true ; }
date_click_right  () {
  ( flock --nonblock 7 || exit 7
    if [ -x "${TERMINAL}" ] && [ -x '/usr/bin/khal' ] ; then
      "${TERMINAL}" /usr/bin/khal interactive
    fi
  ) 7>"${SYSINFO_FLOCK_DIR}/date_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
date_print () {
  pre=' '
  # Get proper icon for the moon phase
  moon="$(echo "$(printf "%.0f" \
    "$(echo "scale=2; ( $(date -d "00:00" +%s) - $(date -d "1999-08-11" +%s) )/(60*60*24)" \
    | bc)") % 29.530588853" | bc | awk '{printf("%d",$1+.5)}')"
  case "${moon}" in
    0)  _out="" ;; 1)  _out="" ;; 2)  _out="" ;; 3)  _out="" ;;
    4)  _out="" ;; 5)  _out="" ;; 6)  _out="" ;; 7)  _out="" ;;
    8)  _out="" ;; 9)  _out="" ;; 10) _out="" ;; 11) _out="" ;;
    12) _out="" ;; 13) _out="" ;; 14) _out="" ;; 15) _out="" ;;
    16) _out="" ;; 18) _out="" ;; 19) _out="" ;; 20) _out="" ;;
    21) _out="" ;; 22) _out="" ;; 23) _out="" ;; 24) _out="" ;;
    25) _out="" ;; 26) _out="" ;; 27) _out="" ;; 28) _out="" ;;
    29) _out="" ;; 30) _out="" ;;
  esac
  case "${SYSINFO_DATE_STYLE}" in
    alt) suf=" $(echo "${_out}" | awk '{print substr($0, 1, 1)}')" ;;
    *)   suf=" $(echo "${_out}" | awk '{print substr($0, 2, 1)}')" ;;
  esac
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    out="%{F${col}}${pre}%{F-}${txt}%{F${col}}${suf}%{F-}"
    echo "%{u${col} +u o${col} +o}${out}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    out="<span color='${col}'>${pre}</span>${txt}<span color='${col}'>${suf}</span>"
    echo "{\"full_text\":\"${out}\"}"
  fi
}
date_wait () {
  date_print
  while : ; do
    # Sleep until the start of next day, (throw in a sec)
    sleep "$(( $(date -d "tomorrow 0" +%s) - $(date +%s) + 5 ))"
    date_print
  done
}
###################
#    _ _     _    #
#  _| |_|___| |_  #
# | . | |_ -| '_| #
# |___|_|___|_,_| #
###################
# Disk module;
#  * Needs the an argument either of target; or root/home
#  * Can change interval using env SYSINFO_DISK_POLL
disk_click_left   () { true ; }
disk_click_middle () { true ; }
disk_click_right  () {
  ( flock --nonblock 7 || exit 7
    if [ -x '/usr/bin/baobab' ] ; then
      /usr/bin/baobab
    fi
  ) 7>"${SYSINFO_FLOCK_DIR}/disk_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
disk_scroll_up    () { true ; }
disk_scroll_down  () { true ; }
disk_print () {
  pre=' '
  txt=''
  if [ -d "${instance}" ] ; then
    dir="${instance}"
    txt="${instance}: "
  elif [ "${instance}" = 'default' ] || [ "${instance}" = 'root' ] ; then
    dir="/"
    txt="Root: "
  elif [ "${instance}" = 'home' ] ; then
    pre=' '
    dir="/home"
    txt="Home: "
  else
    exit 1
  fi
  prc="$(df --human-readable --portability --local \
    | awk "{if(\$6 == \"${dir}\"){print substr(\$5, 1, length(\$5)-1)}}")"

  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    if [ "${prc}" -gt 90 ] ; then
      out="%{F${col}}${pre}%{F-}${txt}${prc}%{F${base09}} %{F-}"
    else
      out="%{F${col}}${pre}%{F-}${txt}${prc}"
    fi
    echo "%{u${col} +u o${col} +o}${out}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    if [ "${prc}" -gt 90 ] ; then
      out="<span color='${col}'>${pre}</span>${txt}${prc}<span color='${col}'> </span>"
      echo "{\"full_text\":\"${out}\",\"urgent\":true}"
    else
      echo "{\"full_text\":\"<span color='${col}'>${pre}</span>${txt}${prc}\"}"
    fi
  fi
}
disk_wait () {
  while : ; do
    disk_print || exit 2
    sleep "${SYSINFO_DISK_POLL}"
  done
}

#######################
#                _ _  #
#  ___ _____ ___|_| | #
# | -_|     | .'| | | #
# |___|_|_|_|__,|_|_| #
#######################
# Email module (depends on inotifp)
#  * Can specify location using SYSINFO_MAIL_LOC
email_click_left   () { true ; }
email_click_middle () { true ; }
email_click_right  () {
  ( flock --nonblock 7 || exit 7
    if [ -x "${TERMINAL}" ] && [ -x '/usr/bin/neomutt' ] ; then
      "${TERMINAL}" /usr/bin/neomutt
    elif [ -x "${TERMINAL}" ] && [ -x '/usr/bin/mutt' ] ; then
      "${TERMINAL}" /usr/bin/mutt
    fi
  ) 7>"${SYSINFO_FLOCK_DIR}/email_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
email_scroll_up    () { true ; }
email_scroll_down  () { true ; }
email_print () {
  # Get number of new emails
  num="$(find "${SYSINFO_EMAIL_LOC}/Inbox/new" | wc -l)"
  # Set up prefix
  if [ "${num}" -le 0 ] ; then
    pre=" "
    mute='yes'
  else
    pre=" "
    mute='no'
  fi
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    out="%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${num}%{-u u- -o o-}"
    if [ "${mute}" = yes ] ; then
      echo "%{F${dim}}${out}%{F-}"
    else
      echo "${out}"
    fi
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    out="<span color='${col}'>${pre}</span>${num}"
    if [ "${mute}" = yes ] ; then
      echo "{\"full_text\":\"${out}\",\"color\":\"${dim}\"}"
    else
      echo "{\"full_text\":\"${out}\"}"
    fi
  fi
}
email_wait () {
  email_print
  # Place inotify watch on the email directory, or exit gracefully
  while : ; do
    inotifywait --recursive --timeout -1 \
      --event modify --event move --event create --event delete \
      "${SYSINFO_EMAIL_LOC}" >/dev/null 2>&1 || exit 2
    email_print
    # Wait a while before trying to add watches again
    sleep 5
  done
}

#################
#  ___          #
# |  _|___ ___  #
# |  _| .'|   | #
# |_| |__,|_|_| #
#################
# Fan module
#  * Takes optional instance
#  * Polling interval can be changed
fan_click_left () { true ; }
fan_click_middle () { true ; }
fan_click_right () { true ; }
fan_scroll_up () { true ; }
fan_scroll_down () { true ; }
fan_print () {
  pre=' '
  # Check fan output
  if [ "${instance}" = 'default' ] ; then
    int='fan'
  else
    int="${instance}"
  fi
  if [ ! -x '/usr/bin/sensors' ] ; then
    exit 1
  fi
  txt="$(/usr/bin/sensors | awk "/${int}/ {print \$2}")"
  if [ -n "${txt}" ] ; then
    # Print text
    if [ "${markup}" = 'lemonbar' ] ; then
      # Format by lemonbar tags
      echo "%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${txt}%{-u u- -o o-}"
    elif [ "${markup}" = 'pango' ] ; then
      # Create pango formatted string
      echo "{\"full_text\":\"<span color='${col}'>${pre}</span>${txt}\"}"
    fi
  fi
}
fan_wait () {
  # Check first if there is an instance
  if [ -x '/usr/bin/sensors' ] ; then
    if [ "${instance}" = 'default' ] ; then
      int='fan'
    else
      int="${instance}"
    fi
    if /usr/bin/sensors | grep --quiet "${int}" ; then
      while : ; do
        fan_print
        sleep "${SYSINFO_FAN_POLL}"
      done
    fi
  fi
}

###########################
#  _                   _  #
# | |_ ___ ___ ___ ___| | #
# | '_| -_|  _|   | -_| | #
# |_,_|___|_| |_|_|___|_| #
###########################
# Kernel module;
#  * Don't do this as interval
kernel_click_left () { true ; }
kernel_click_middle () { true ; }
kernel_click_right () { true ; }
kernel_scroll_up () { true ; }
kernel_scroll_down () { true ; }
kernel_print () {
  txt="$(/usr/bin/uname --kernel-release)"
  pre=' '
  #ico=' '
  #ico=' '
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
  # Format by lemonbar tags
    echo "%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${txt}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    echo "{\"full_text\":\"<span color='${col}'>${pre}</span>${txt}\"}"
  fi
}
kernel_wait () {
  kernel_print
  exit 0
}

#####################################
#  _           _                 _  #
# | |_ ___ _ _| |_ ___ ___ ___ _| | #
# | '_| -_| | | . | . | .'|  _| . | #
# |_,_|___|_  |___|___|__,|_| |___| #
#         |___|                     #
#####################################
# Keyboard module;
#  * For keyboard backlight; BRI_KBD needs to be in environment variables
keyboard_click_left () {
  if [ "${XDG_SESSION_TYPE}" = 'x11' ] ; then
    if [ -x '/usr/bin/xkb-switch' ] ; then
      /usr/bin/xkb-switch --next
    fi
  elif [ -n "${SWAYSOCK}" ] ; then
    true
  fi
}
keyboard_click_middle () { true ; }
keyboard_click_right () { true ; }
keyboard_scroll_up () {
  if [ -x '/usr/bin/light' ] ; then
    device="$(/usr/bin/light -L 2>/dev/null | awk '/kbd_backlight/ {print $1}')"
    if [ -n "${device}" ] ; then
      /usr/bin/light -Ars "${device}" 1
    fi
  fi
}
keyboard_scroll_down () {
  if [ -x '/usr/bin/light' ] ; then
    device="$(/usr/bin/light -L 2>/dev/null | awk '/kbd_backlight/ {print $1}')"
    if [ -n "${device}" ] ; then
      /usr/bin/light -Urs "${device}" 1
    fi
  fi
}
keyboard_print () {
  # Initialize
  pre=' '
  suf=''
  # Different protocols for different software
  if [ "${XDG_SESSION_TYPE}" = 'x11' ] ; then
    # Get keymap
    state="$(xkb-switch --print)"
  elif [ -n "${SWAYSOCK}" ] ; then
    state="$(/usr/bin/swaymsg --type get_inputs | jq \
      '.[] | select(.name | test(".*[K,k]eyboard.*")) | select(.type == "keyboard") | .xkb_active_layout_name' \
      | tail -n 1)"
  else
    exit 1
  fi
  # Seperate language and layout
  lang="$(echo "${state}"   | awk -F '[ ()]' '{print $1}')"
  layout="$(echo "${state}" | awk -F '[ ()]' '{print $2}')"
  # Start laying out text (with emoji if possible)
  case "${lang}" in
    us) txt='🇺🇸' ;;
    tr) txt='🇹🇷' ;;
    *)  txt="$(echo "${lang}" | awk '{print toupper($0)}')"
  esac
    # Add the layout
    if [ -n "${layout}" ] ; then
      txt="${txt} ("${layout}")"
    else
      txt="${txt} (qwerty)"
    fi
  # Get the keyboard backlight if it is there
  if [ -x '/usr/bin/light' ] ; then
    device="$(/usr/bin/light -L 2>/dev/null | awk '/kbd_backlight/ {print $1}')"
    if [ -n "${device}" ] ; then
      blevel="$(/usr/bin/light -Gs "${device}")"
      if   [ "${blevel}" -gt 66 ] ; then suf=" "
      elif [ "${blevel}" -gt 33 ] ; then suf=" "
      elif [ "${blevel}" -gt  0 ] ; then suf=" "
      fi
    fi
  fi
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    out="%{F${col}}${pre}%{F-}${txt}%{F${col}}${suf}%{F-}"
    echo "%{u${col} +u o${col} +o}${out}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    out="<span color='${col}'>${pre}</span>${txt}<span color='${col}'>${suf}</span>"
    echo "{\"full_text\":\"${out}\"}"
  fi
}
keyboard_wait() {
  # Check if kbd device exists to wait for it
  kbdlight_wait() {
    if [ -x '/usr/bin/light' ] && [ -x '/usr/bin/acpi_listen' ] ; then
      device="$(/usr/bin/light -L 2>/dev/null | awk '/kbd_backlight/ {print $1}')"
      if [ -n "${device}" ] ; then
        /usr/bin/acpi_listen | while read -r event ; do
          if echo "${event}" | grep --quiet 'kbd' ; then
            keyboard_print
          fi
        done
      fi
    fi
  }
  keymap_wait() {
    if [ "${XDG_SESSION_TYPE}" = 'x11' ] && [ -x '/usr/bin/xkb-switch' ] ; then
      /usr/bin/xkb-switch -W | while read -r line ; do
        keyboard_print
      done
    elif [ -n "${SWAYSOCK}" ] ; then
      /usr/bin/swaymsg --type subscribe '["input"]' --monitor | while read -r line ; do
        if [ "$(echo "${line}" | jq '.change' --raw)" = 'xkb_layout' ] ; then
          keyboard_print
        fi
      done
    fi
  }
  keyboard_print
  kbdlight_wait &
  keymap_wait
}

#################################
#  _____ ___ _____ ___ ___ _ _  #
# |     | -_|     | . |  _| | | #
# |_|_|_|___|_|_|_|___|_| |_  | #
#                         |___| #
#################################
# Memory module
#  * Takes no arguments
#  * Can change polling interval using SYSINFO_MEM_POLL
memory_click_left   () { true; }
memory_click_middle () { true ; }
memory_click_right  () {
  ( flock --nonblock 7 || exit 7
    if [ -x "${TERMINAL}" ] & [ -x '/usr/bin/htop' ] ; then
      "${TERMINAL}" /usr/bin/htop
    fi
  ) 7>"${SYSINFO_FLOCK_DIR}/mem_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
memory_scroll_up    () { true ; }
memory_scroll_down  () { true ; }
memory_print () {
  # Initialize
  pre=' '
  suf=''
  # Get memory info (raw and human readable
  info_raw="$(free -m)"
  info="$(free -h)"
  # Get RAM usage
  ram_perc="$(echo "${info_raw}"  | awk '/Mem:/  {printf("%.0f", $3 / $2 * 100.0);}')"
  ram_amnt="$(echo "${info}"      | awk '/Mem:/  {print $3}')"
  txt="${ram_amnt} (${ram_perc})"
  # Get SWAP usage, and include it if sifnificant
  swap_perc="$(echo "${info_raw}" | awk '/Swap:/ {printf("%.0f", $3 / $2 * 100.0);}')"
  swap_amnt="$(echo "${info}"     | awk '/Swap:/ {print $3}')"
  if [ "${swap_perc}" -gt 0 ] ; then
    txt="${_txt}樂${swap_amnt} (${swap_perc})"
    suf=' 易'
  fi
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    out="%{F${col}}${pre}%{F-}${txt}%{F${col}}${suf}%{F-}"
    echo "%{u${col} +u o${col} +o}${out}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    out="<span color='${col}'>${pre}</span>${txt}<span color='${col}'>${suf}</span>"
    echo "{\"full_text\":\"${out}\"}"
  fi
}
memory_wait () {
  memory_print
  while : ; do
    sleep "${SYSINFO_MEM_POLL}"
    memory_print || exit 2
  done
}

###################
#              _  #
#  _____ ___ _| | #
# |     | . | . | #
# |_|_|_|  _|___| #
#       |_|       #
###################
# MPD module;
#  * Can take instance name of; default, consume, repeat, shuffle, single, toggle
mpd_click_left   () {
  case "${instance}" in
    default|song)     /usr/bin/mpc toggle         >/dev/null 2>&1 ;;
    rewind)           /usr/bin/mpc seek '-10'     >/dev/null 2>&1 ;;
    fastforward)      /usr/bin/mpc seek '+10'     >/dev/null 2>&1 ;;
    *)                /usr/bin/mpc "${instance}"  >/dev/null 2>&1 ;;
  esac
}
mpd_click_middle () {
  /usr/bin/mpc stop
}
mpd_click_right  () {
  ( flock --nonblock 7 || exit 7
    if [ -x '/usr/bin/cantata' ] ; then
      /usr/bin/cantata >/dev/null 2>&1 &
    fi
  ) 7>"${SYSINFO_FLOCK_DIR}/mpd_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
mpd_scroll_up () { true ; }
mpd_scroll_down () { true ; }
mpd_print () {
  # Get MPD info, even if it breaks
  info="$(mpc 2>&1)"
  lines="$(echo "${info}" | wc --lines)"
  # Initialize things as empty
  pre=''
  suf=''
  txt=''
  mute='no'
  # Configure buttons; but only if;
  #  3 lines: OK (There is playback)
  #  2 lines: Might be a database update
  #  1 lines: Empty playlist (iff there is no error)
  if  [ "${lines}" = '3' ] || \
    ( [ "${lines}" = '2' ] && echo "${info}" | grep --quiet 'Updating' ) || \
    ( [ "${lines}" = '1' ] && echo "${info}" | grep --quiet --invert-match 'error' )
    then
    # Buttons
    if [ "${instance}" = 'next' ] ; then
      txt='怜'
    elif [ "${instance}" = 'prev' ] ; then
      txt='玲'
    elif [ "${instance}" = 'rewind' ] ; then
      txt='丹'
    elif [ "${instance}" = 'fastforward' ] ; then
      txt=''
    elif [ "${instance}" = 'random' ] ; then
      if echo "${info}" | grep --quiet "${instance}: on" ; then
        pre='咽'
      else
        txt='咽'
      fi
    elif [ "${instance}" = 'repeat' ] ; then
      if echo "${info}" | grep --quiet "${instance}: on" ; then
        pre='凌'
      else
        txt='稜'
      fi
    elif [ "${instance}" = 'consume' ] ; then
      if echo "${info}" | grep --quiet "${instance}: on" ; then
        pre=''
      else
        txt=''
      fi
    elif [ "${instance}" = 'single' ] ; then
      if echo "${info}" | grep --quiet "${instance}: on" ; then
        pre='綾'
      else
        txt='綾'
      fi
    elif [ "${instance}" = 'toggle' ] ; then
      # It's playing/paused only if there are 3 lines
      if [ "${lines}" = '3' ] ; then
        if echo "${info}" | grep --quiet 'paused' ; then
          txt='契'
        else
          txt=''
        fi
      # It is stopped
      else
        txt='懶'
      fi
    elif [ "${instance}" = 'song' ] || [ "${instance}" = 'default' ] ; then
      pre=' '
      # Check if mpdscribble is working
      if pgrep mpdscribble >/dev/null 2>&1; then
        suf=' '
      fi
      # Get song title if it's playing: 3 lines
      if [ "${lines}" = '3' ] ; then
        tit="$(echo "${info}" | sed --quiet '1p' | awk -F ' - ' '{print $2}')"
        art="$(echo "${info}" | sed --quiet '1p' | awk -F ' - ' '{print $1}')"
        # Shorten fields
        if [ "$(echo "${tit}" | wc --chars)" -gt "${SYSINFO_MPD_MAXLEN}" ] ; then
          tit="$(echo "${tit}" \
            | awk "{print substr(\$0, 1, ${SYSINFO_MPD_MAXLEN})}")…"
        fi
        if [ "$(echo "${art}" | wc --chars)" -gt "${SYSINFO_MPD_MAXLEN}" ] ; then
          art="$(echo "${art}" \
            | awk "{print substr(\$0, 1, ${SYSINFO_MPD_MAXLEN})}")…"
        fi
        txt="${tit}${art}"
        # Mute if paused
        if echo "${info}" | grep --quiet 'paused' ; then
          mute='yes'
        fi
      elif  [ "${lines}" = '2' ] ; then
        txt='Database update…'
      else
        txt='Empty playlist…'
        mute='yes'
      fi
    fi
  # If none of the conditions are satisfied; just apply a disconnect suffix to default
  elif [ "${instance}" = 'song' ] || [ "${instance}" = 'default' ] ; then
    pre='ﱙ'
    # Check if mpdscribble is working
    if pgrep mpdscribble >/dev/null 2>&1; then
      suf=' '
    fi
  fi
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    out="%{F${col}}${pre}%{F-}${txt}%{F${col}}${suf}%{F-}"
    if [ "${mute}" = 'yes' ] ; then
      out="%{F${dim}}${out}%{F-}"
    fi
    echo "%{u${col} +u o${col} +o}${out}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    png="<span color='${col}'>${pre}</span>${txt}<span color='${col}'>${suf}</span>"
    if [ "${mute}" = 'yes' ] ; then
      echo "{\"full_text\":\"${png}\",\"color\":\"${dim}\"}"
    else
      echo "{\"full_text\":\"${png}\"}"
    fi
  fi
}
mpd_wait() {
  mpd_print
  # Retry to connect every 30 seconds if the mpc command gives error
  while : ; do
    while : ; do
      mpc --quiet idle >/dev/null || break
      mpd_print
    done
    sleep "${SYSINFO_MPD_POLL}"
  done
}

###################################
#          _                 _    #
#  ___ ___| |_ _ _ _ ___ ___| |_  #
# |   | -_|  _| | | | . |  _| '_| #
# |_|_|___|_| |_____|___|_| |_,_| #
###################################
# Network module;
#  * Either fixes an interface using instance; or picks it using ip route
#  * Expects the interfaces to be labelled ethernet or wifi
network_click_left ()   { true ; }
network_click_middle () { true ; }
network_click_right ()  { true ; }
network_scroll_up ()    { true ; }
network_scroll_down ()  { true ; }
network_print () {
  # Get the interface
  if [ "${instance}" = 'default' ] ; then
    intfc="$(ip route | awk '/^default via/ {print $5}')"
  else
    intfc="${instance}"
    int_list="$(ip addr | awk -F ': ' '/^[0-9]+/ {print $2}')"
    # Check if valid interface
    echo "${int_list}" | grep --quiet "${intfc}" || exit 1
  fi
  # Get icon
  case "${intfc}" in
    eth*|en*) pre=' ' ;;
    wifi|wl*) pre=' ' ;;
    tether)   pre='禍 ' ;;
    blue*)    pre=' ' ;;
    lan*)     pre=' ' ;;
    *)        pre='爵 ' ;;
  esac
  # Get IP address for everybody
  txt="$(ip addr show "${intfc}" 2>/dev/null | awk '/inet/ {print $2}' | head -n 1)"
  if [ -z "${txt}" ] ; then
    txt='N/A'
  # Get SSID if also wireless
  elif [ "${txt}" = 'wifi' ] || echo "${txt}" | grep --quiet 'wl' ; then
    txt="$(iwctl station "${intfc}" get-networks | awk '/>/ {print $0}')${txt}"
  fi
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
  # Format by lemonbar tags
    echo "%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${txt}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    echo "{\"full_text\":\"<span color='${col}'>${pre}</span>${txt}\"}"
  fi
}
network_wait () {
  while : ; do
    network_print
    # Wait for one line; then chillax a bit
    ( ip monitor & echo "${!}" && wait ) | ( 
      trap 'kill "${thispid}"; trap - EXIT' EXIT
      thispid="$(head -1)"
      grep --max-count=1 --quiet --line-buffered ''
    )
    sleep .2
  done
}

#########################################
#          _                   _ _      #
#  ___ _ _| |___ ___ ___ _ _ _| |_|___  #
# | . | | | |_ -| -_| .'| | | . | | . | #
# |  _|___|_|___|___|__,|___|___|_|___| #
# |_|                                   #
#########################################
# Pulseaudio module;
#  * Only needs pacmd (pulseaudion) and pactl (libpulse)
#  * Needs a instance of either 'sink' or 'source'

pulseaudio_click_left () { # Left click action
  # Toggle mute
  /usr/bin/pactl "set-${instance}-mute" \
    "@DEFAULT_$(echo ${instance} | awk '{print toupper($0)}')@" toggle
}
pulseaudio_click_middle () { # Middle mouse action
  if [ "${instance}" = 'source' ] ; then
    _cmd='source-output'
  elif [ "${instance}" = 'sink' ] ; then
    _cmd='sink-input'
  fi
  # Change default sink; and move all inputs to the new sink
  _info="$(/usr/bin/pacmd "list-${instance}s")"
  _ndev="$(echo "${_info}" | grep --count 'index:')"
  _inds="$(echo "${_info}" | grep 'index:' | grep --only-matching '[0-9]\+')"
  # Get default sink
  _icur="$(echo "${_info}" | grep 'index:' \
    | grep --line-number --only-matching '*' \
    | grep --only-matching '[0-9]\+')"
  # Get the next sink
  _inew="$(( ( _icur % _ndev ) + 1 ))"
  _dnew="$(echo "${_inds}" | sed --quiet "${_inew}p")"
  # Switch to this default
  /usr/bin/pacmd "set-default-${instance}" "${_dnew}"
  # Switch all inputs here
  _inputs="$(/usr/bin/pacmd "list-${_cmd}s")"
  _iindex="$(echo "${_inputs}" | awk '/index:/ {print $2}')"
  _iflags="$(echo "${_inputs}" | grep 'flags:')"
  _i=1
  while [ "${_i}" -le "$(echo "${_iindex}" | wc --lines)" ] ; do
    _ind="$(echo "${_iindex}" | sed --quiet "${_i}p")"
    _fla="$(echo "${_iflags}" | sed --quiet "${_i}p")"
    # Don't move if the DONT_MOVE flag is on
    if echo "${_fla}" | grep --invert-match --quiet 'DONT_MOVE' ; then
      /usr/bin/pacmd "move-${_cmd}" "${_ind}" "${_dnew}"
    fi
    _i="$(( _i + 1 ))"
  done
}
pulseaudio_click_right () { # Right mouse action
  ( flock --nonblock 7 || exit 7
    if [ -x '/usr/bin/pavucontrol' ] ; then
      /usr/bin/pavucontrol
    fi
  ) 7>"${SYSINFO_FLOCK_DIR}/pulse_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
pulseaudio_scroll_up () { # Scroll up action
  if [ "${instance}" = 'source' ] ; then
    _cap='Source'
    _def='@DEFAULT_SOURCE@'
  elif [ "${instance}" = 'sink' ] ; then
    _cap='Sink'
    _def='@DEFAULT_SINK@'
  fi
  # Increase volume if the default sink volume is >100%
  # Default sink
  _d_sink="$(/usr/bin/pactl info | awk -F ': ' "/Default ${_cap}/ {print \$2}")"
  _d_lnum="$(/usr/bin/pactl list "${instance}s" short \
    | grep --line-number "${_d_sink}" | cut --delimiter ':' --fields '1')"
  # Volume of default sink
  _vol="$(/usr/bin/pactl list "${instance}s" | awk '/^\sVolume/ {vol=0; n=0;
    for (i = 1; i <= NF; i++) {
      if( substr($i, length($i), 1) == "%" ) {
        vol += substr($i, 1, length($i) - 1); n++; }
      } printf("%.0f\n", vol/n);}' | sed --quiet "${_d_lnum}p")"
  if [ "${_vol}" -lt 100 ] ; then
    /usr/bin/pactl "set-${instance}-volume" "${_def}" +1%
  else
    /usr/bin/pactl "set-${instance}-volume" "${_def}" 100%
  fi
}
pulseaudio_scroll_down () { # Scroll down action
  # Launch and disown pavucontrol
  /usr/bin/pactl "set-${instance}-volume" \
    "@DEFAULT_$(echo "${instance}" | awk '{print toupper($0)}')@" -1%
}
pulseaudio_print () {   # Print text
  # Default instance does not work, only source or sink does
  if [ "${instance}" = 'default' ] ; then
    exit 3
  #--------------------------#
  #---SINK-type-formatting---#
  #--------------------------#
  elif [ "${instance}" = 'sink' ] ; then 
    # Get pulseaudio state info
    pinfo="$(/usr/bin/pactl info)"
    sinks="$(/usr/bin/pactl list "${instance}s")"
    ssink="$(/usr/bin/pactl list "${instance}s" short)"
    ports="$(echo "${sinks}" | awk -F ': ' \
      '/Active Port/ {print $2}')"
    muted="$(echo "${sinks}" | awk -F ': ' \
      '/Mute/ {print $2}')"
    volms="$(echo "${sinks}" | awk '/^\sVolume/ {vol=0; n=0;
      for (i = 1; i <= NF; i++) {
        if( substr($i, length($i), 1) == "%" ) {
          vol += substr($i, 1, length($i) - 1); n++; }
        } printf("%.0f\n", vol/n);}')"
    # Get information about the default sink
    d_sink="$(echo "${pinfo}" | awk -F ': ' '/Default Sink/ {print $2}')"
    d_lnum="$(echo "${ssink}" | grep --line-number "${d_sink}" \
      | cut --delimiter ':' --fields '1')"
    d_port="$(echo "${ports}" | sed --quiet "${d_lnum}p")"
    d_mute="$(echo "${muted}" | sed --quiet "${d_lnum}p")"
    d_volm="$(echo "${volms}" | sed --quiet "${d_lnum}p")"
    # Determine icon for the sink
    case "${d_port}" in
      *hdmi*)                                         pre="﴿ " ;;
      *headset*)            [ "${d_mute}" = 'no' ] && pre=" "  || pre=" "  ;;
      *a2dp*)               [ "${d_mute}" = 'no' ] && pre="﫽 " || pre="﫾 " ;;
      *hifi*|*stereo*)                                pre="﫛 " ;;
      *headphone*|*lineout*)[ "${d_mute}" = 'no' ] && pre=" "  || pre="ﳌ "  ;;
      *speaker*)            [ "${d_mute}" = 'no' ] && pre="蓼 " || pre="遼 " ;;
      *network*)                                      pre="爵 " ;;
      *)                    [ "${d_mute}" = 'no' ] && pre="墳 " || pre="ﱝ "  ;;
    esac
    # Check if it's a bluetooth sink, adjust suffix
    if echo "${d_sink}" | grep -q 'bluez' ; then
      suf=" "
    else
      suf=""
    fi
  #----------------------------#
  #---SOURCE-type-formatting---#
  #----------------------------#
  elif [ "${instance}" = 'source' ] ; then 
    # Get pulseaudio state info
    pinfo="$(/usr/bin/pactl info)"
    srces="$(/usr/bin/pactl list "${instance}s")"
    ssrcs="$(/usr/bin/pactl list "${instance}s" short)"
    # Get device.icon_name field
    iconn="$(echo "${srces}" | awk -F ' = ' \
      '/device.icon_name/ {print substr($2, 2, length($2) - 2)}')"
    muted="$(echo "${srces}" | awk -F ': ' \
      '/Mute/ {print $2}')"
    volms="$(echo "${srces}" | awk '/^\sVolume/ {vol=0; n=0;
      for (i = 1; i <= NF; i++) {
        if( substr($i, length($i), 1) == "%" ) {
          vol += substr($i, 1, length($i) - 1); n++; }
        } printf("%.0f\n", vol/n);}')"
    # Get information about the default sink
    d_src="$(echo "${pinfo}" | awk -F ': ' '/Default Source/ {print $2}')"
    d_lno="$(echo "${ssrcs}" | grep --line-number "${d_src}" \
      | cut --delimiter ':' --fields '1')"
    d_icon="$(echo "${iconn}" | sed --quiet "${d_lno}p")"
    d_mute="$(echo "${muted}" | sed --quiet "${d_lno}p")"
    d_volm="$(echo "${volms}" | sed --quiet "${d_lno}p")"
    # Determine icon for the sink
    case "${d_icon}" in
      audio-card-pci) [ "${d_mute}" = 'no' ] && pre=" "  || pre=" " ;;
      camera-web-usb)                           pre="犯 " ;;
      *)              [ "${d_mute}" = 'no' ] && pre=" "  || pre=" " ;;
    esac
    # Check if it's a bluetooth source
    if echo "${d_src}" | grep -q 'bluez' ; then
      suf=" "
    else
      suf=""
    fi
  fi

  # Formatting and printing
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    txt="%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${d_volm}%{-u u- -o o-}"
    if [ "${d_mute}" = 'yes' ] ; then
      txt="%{F${dim}}${txt}%{F-}"
    fi
    echo "${txt}"
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    png="<span color='${col}'>${pre}</span>${d_volm}<span color='${col}'>${suf}</span>"
    # Start assemling the json string
    txt="{\"full_text\":\"${png}\""
    if [ "${d_mute}" = 'yes' ] ; then
      echo "${txt},\"color\":\"${dim}\"}"
    else
      echo "${txt}}"
    fi
  fi
}
pulseaudio_wait () { # Listener loop with callback
  if [ "${instance}" != 'source' ] && [ "${instance}" != 'sink' ] ; then
    exit 2
  fi
  # Print once
  pulseaudio_print
  /usr/bin/pactl subscribe 2>/dev/null | while read -r _line ; do
    if echo "${_line}" \
      | grep --quiet --ignore-case "${instance}\|'change' on server #" ; then
      pulseaudio_print
    fi
  done
}

#################
#  ___ ___ ___  #
# |  _|_ -|_ -| #
# |_| |___|___| #
#################
# RSS module
#  * Does not take instances
rss_click_left   () { true ; }
rss_click_middle () { true ; }
rss_scroll_up    () { true ; }
rss_scroll_down  () { true ; }
rss_click_right  () {
  ( flock --nonblock 7 || exit 7
    if [ -x "${TERMINAL}" ] && [ -x '/usr/bin/newsboat' ] ; then
      "${TERMINAL}" '/usr/bin/newsboat'
    fi
  ) 7>"${SYSINFO_FLOCK_DIR}/rss_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
rss_print () {
  pre=' '
  tmp="$(mktemp)"
  new="$(/usr/bin/newsboat "--cache-file=${tmp}" -x print-unread | awk '{print $1}')"
  rm "${tmp}"
  if [ "${new}" = '0' ] ; then
    mute='yes'
  else
    mute='no'
  fi
    # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    out="%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${new}%{-u u- -o o-}"
    if [ "${mute}" = yes ] ; then
      echo "%{F${dim}}${out}%{F-}"
    else
      echo "${out}"
    fi
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    out="<span color='${col}'>${pre}</span>${new}"
    if [ "${mute}" = yes ] ; then
      echo "{\"full_text\":\"${out}\",\"color\":\"${dim}\"}"
    else
      echo "{\"full_text\":\"${out}\"}"
    fi
  fi
}
rss_wait () {
  # Poll this
  while : ; do
    rss_print
    sleep "${SYSINFO_RSS_POLL}"
  done
}

#####################
#  _         _      #
# | |_ ___ _| |___  #
# |  _| . | . | . | #
# |_| |___|___|___| #
#####################
# Todo module (depends on todoman)
#  * Can specify location using SYSINFO_TODO_LOC
#  * Can specify text length SYSINFO_TODO_MAXLEN
todo_click_left   () { true ; }
todo_click_middle () { true ; }
todo_scroll_up    () { true ; }
todo_scroll_down  () { true ; }
todo_click_right  () { true ; }
todo_print () {
  pre='省 '
  txt="$(todo --porcelain list --sort priority | jq -r '.[0]."summary"')"
  # Mute if quiet
  if [ "${txt}" = 'null' ] ; then
    mute='yes'
    txt='Nothing todo'
  else
    mute='no'
  fi
  # Shorten text
  if [ "$(echo "${txt}" | wc --chars)" -gt "${SYSINFO_TODO_MAXLEN}" ] ; then
    txt="$(echo "${txt}" | awk "{print substr(\$0, 1, ${SYSINFO_TODO_MAXLEN})}")…"
  fi
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    # Format by lemonbar tags
    out="%{u${col} +u o${col} +o}%{F${col}}${pre}%{F-}${txt}%{-u u- -o o-}"
    if [ "${mute}" = yes ] ; then
      echo "%{F${dim}}${out}%{F-}"
    else
      echo "${out}"
    fi
  elif [ "${markup}" = 'pango' ] ; then
    # Create pango formatted string
    out="<span color='${col}'>${pre}</span>${txt}"
    if [ "${mute}" = yes ] ; then
      echo "{\"full_text\":\"${out}\",\"color\":\"${dim}\"}"
    else
      echo "{\"full_text\":\"${out}\"}"
    fi
  fi
}
todo_wait () {
  todo_print
  # Place inotify watch on the calendar directory, or exit gracefully
  while : ; do
    inotifywait --recursive --timeout -1 \
      --event modify --event move --event create --event delete \
      "${SYSINFO_TODO_LOC}" >/dev/null 2>&1 || exit 2
    todo_print
    # Wait a while before trying to add watches again
    sleep 5
  done
}

#############################
#            _     _        #
#  _ _ ___ _| |___| |_ ___  #
# | | | . | . | .'|  _| -_| #
# |___|  _|___|__,|_| |___| #
#     |_|                   #
#############################
# Update module
#  * Does not take arguments; but polling can be changed
update_click_left   () { true ; }
update_click_middle () { true ; }
update_click_right  () {
  dis="$(lsb_release --id | awk -F ':\\s' '{print $2}')"
  ( flock --nonblock 7 || exit 7
    case "${dis}" in
      Arch)   if [ -x '/usr/bin/pamac'    ] ; then /usr/bin/pamac    ; fi ;;
      Gentoo) if [ -x '/usr/bin/porthole' ] ; then /usr/bin/porthole ; fi ;;
    esac
  ) 7>"${SYSINFO_FLOCK_DIR}/rss_${IDENTIFIER}_right" >/dev/null 2>&1 &
}
update_scroll_up    () { true ; }
update_scroll_down  () { true ; }
update_print () {
  dis="$(lsb_release --id | awk -F ':\\s' '{print $2}')"
  pre=''
  txt=''
  case "${dis}" in
    Arch)
      pre=' '
      if [ -x '/usr/bin/checkupdates' ] ; then
        txt="$(checkupdates 2>/dev/null | wc --lines)"
      else
        txt="…"
      fi
      ;;
    Gentoo)
      pre=' '
      if [ -x '/usr/bin/eix' ] ; then
        txt="$(eix --installed --upgrade 2>/dev/null | wc --lines)"
      else
        txt="…"
      fi
      ;;
  esac
  # Print text
  if [ "${markup}" = 'lemonbar' ] ; then
    if [ "${txt}" = '0' ] ; then
      out="%{F${col}}${pre}%{F-}%{F${dim}}${txt}%{F-}"
    else
      out="%{F${col}}${pre}%{F-}${txt}"
    fi
    echo "%{u${col} +u o${col} +o}${out}%{-u u- -o o-}"
  elif [ "${markup}" = 'pango' ] ; then
    out="<span color='${col}'>${pre}</span>${txt}"
    if [ "${txt}" = '0' ] ; then
      echo "{\"full_text\":\"${out}\",\"color\":\"${dim}\"}"
    else
      echo "{\"full_text\":\"${out}\"}"
    fi
  fi
}
update_wait () {
  while : ; do
    update_print
    sleep "${SYSINFO_UPDATE_POLL}"
  done
}

##########################
# ___  ___      _        #
# |  \/  |     (_)       #
# | .  . | __ _ _ _ __   #
# | |\/| |/ _` | | '_ \  #
# | |  | | (_| | | | | | #
# \_|  |_/\__,_|_|_| |_| #
##########################

# Create file lock directory
if [ ! -e "${SYSINFO_FLOCK_DIR}" ] ; then
  mkdir --parents "${SYSINFO_FLOCK_DIR}"
elif [ ! -d "${SYSINFO_FLOCK_DIR}" ] ; then
  exit 1
fi

# Run the waiter loops if the module exists
if type "${name}_wait" 2>/dev/null | grep --quiet 'function' ; then
  "${name}_wait" || exit &
else
  echo "${name} module does not exist!"
  exit 1
fi

# Exit if one of the static modules
if [ "${name}" = 'kernel' ] ; then
  exit 0
fi

# Responde to inputs
while read -r input_button ; do
  case "$(echo "${input_button}" | jq --raw-output '.button')" in
    1) "${name}_click_left"   || continue ;;
    2) "${name}_click_middle" || continue ;;
    3) "${name}_click_right"  || continue ;;
    4) "${name}_scroll_up"    || continue ;;
    5) "${name}_scroll_down"  || continue ;;
    *) true ;;
  esac
done
